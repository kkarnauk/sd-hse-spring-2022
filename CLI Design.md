# CLI Design

Участники:
- Лебедев Егор
- Худяков Юрий
- Карнаухов Кирилл
- Сурков Петр

Начнём с описания классов из которых будет состоять наше AST, на диаграмме они представлены в центре в блоке `Tree`. 
Главный абстрактный класс – `Command`. Это общий класс для любого поддерживаемого выражения в нашем баше. 
Его наследники – конкретные возможные варианты, в которые отображаются вводимые пользователем команды, а именно: 
- `CatCommand`: выводит содержимое
  - При наличии аргументов: файлов, переданных в аргументах
  - При отсутствии аргументов: своего потока ввода в свой поток вывода
- `EchoCommand`: выводит переданные аргументы как строки в свой поток вывода. Игнорирует поток ввода
- `PwdCommand`: выводит текущую директорию. Принимает 0 или 1 аргумент, любое количество в любом случае игнорирует
- `WcCommand`: выводит количество строк, количество слов и количество байт
  - При наличии единственного аргумента: в файле
  - При отсутствии аргументов: в своем потоке ввода
- `ExitCommand`: завершает исполнение с кодом возврата 0. При использовании в пайплайнах, если есть следующая
команда, игнорируется
- `EmptyCommand`: ничего не делает. Обычно представлена пустой строчкой
- `GrepCommand`:
  - Производит поиск строк, соответствующих паттерну
  - Паттерн - регулярное выражение, работающее в соответствии с [Kotlin Regex](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-regex/)
  - Имеет набор аргументов для регуляции работы:
    - `-i`: игнорировать регистр при поиске
    - `-w`: поиск только слова целиком
      - найдутся те подстроки, которые ограничены с обеих сторон символами, 
      являющимися буквами (JVM `Char.isLetter()`), цифрами (JVM `Char.isDigit()`), или нижним подчёркиванием (`_`) 
    - `-A <n>`: выведет дополнительно `n` (`n >= 0`) строк после совпадения. В случае пересечения областей строки будут
    выведены единожды и в той же последовательности, что и в файле
  - Для разбора ключей была использована библиотека [Clikt](https://ajalt.github.io/clikt/): ее выбор обусловлен тем, что ее использование максимальное простое, она достаточно популярна, и написана она специально для котлина: ее использование получается более идиоматичным и понятным
- `PipeCommand`: перенаправляет поток вывода левой команды в поток ввода правой команды. Делает это жадно: 
считывает весь вывод левой команды и только потом передаёт его в правую
- `ExternalCommand`: запускает в отдельном процессе неизвестную интерпретатору команду
- `AssignmentCommand`: сохраняет в `Environment` строковое значение переменной 


Теперь разберём класс `Grammar`. Он содержит правила для лексера и парсера, с помощью которых [better-parse](https://github.com/h0tk3y/better-parse) сможет лексить и парсить выражения, он наследуется от класса `Grammar<Program>` из этой библиотеки.

Про Grammar:
- описание правил лексера
  - `catToken` должен матчить “cat”
  - по аналогии работают `echoToken`, `wcToken`, `pwdToken`, `exitToken`, `grepToken`
  - `pipeToken` должен матчить “|”
  - по аналогии работают остальные токены для спецсимволов
  - `wsToken` должен матчить пробельные символы
  - `identifierToken` должен матчить все идентификаторы (аргументы, названия переменных, и т.п.). 
  Все кавычки из идентификаторов удаляются (то есть использовать файлы с кавычкой в названии не представляется
  возможным).
  
- описание правил парсера для термов
  - `catTerm` должен парсить команду `cat` с проивзольным числом аргументов
  - Аналогично `echoTerm`, `grepToken`, `ExternalCommand`
  - `wcTerm` должен парсить команду `wc` с 0 или 1 аргументом
  - `pwdTerm` должен парсить команду `pwd` с 0 или 1 аргументом (см. `PwdCommand`)
  - `exitTerm` должен парсить команду `exit` без аргументов

- более высокоуровневые правила парсера
  - `term` принимает любой возможный конкретный терм, то есть `catTerm` и остальные
  - `pipeChain` должен левоассоциативно парсить цепочку из перечисленных выше термов, разделенных `|` и строить дерево
  (почти бамбук)
  - `literal` совокупное описание идентефикаторов с учётом кавычек (см. ниже о кавычках)
  - `assignment` должен парсить присвоение `<literal> = <literal>`, пробелов может быть любое число
    - В случае если левый `literal` также может быть интерпретирован как команда (например, `echo`), то присвоение всё
    равно победит (будет присвоено значение переменной `echo`)
  

Но этот класс не будет использоваться напрямую в пайплайне. У нас будут некие обёртки. Лексер представим интерфейсом `Lexer` с единственной требуемой функцией – `tokenize(String): List<Token>`, то есть получать по строке список токенов. Реализовывать интерфейс `Lexer` будет `LexerAdapter` уже как раз используя `Grammar`. Аналогично для парсинга: интерфейс `Parser` требует единственную функцию – `parse`, которая по списку токенов возвращает верхний элемент AST – `Command`. Этот интерфейс будет реализовывать класс `ParserAdapter` опять же используя `Grammar`. Таким образом мы абстрагируемся от конкретной библиотеки для лексинга и парсинга, что позволит легче заменить её при необходимости или проводить тестирование.


Лексинг проводится в 2 этапа.
- Во время первого этапа, мы проходимся по строчке. Если мы находимся не внутри одинарных кавычек, то при обнаружении строки `$var_name` смотрим в уже накопленный ранее `Environment` (о нём написано ниже). Если в нём есть нужная переменная, то мы заменяем эту строку на значение из `Environment`, иначе заменяем на пустую строку.
- Во время второго этапа: разбиваем строку на токены в соответствии с правилами выше. Получили список токенов.

С кавычками будем делать следующее:
- Первый лексинг найдёт нам `quoteToken` (текст в одинарных кавычках) и `doubleQuoteToken` (текст в двойных кавычках)
- После чего мы посмотрим на содержимое `doubleQuoteToken` и там применим все подстановки (найдя все доллары внутри, можем ещё учесть экранирование, посчитав сколько перед долларом бэкслешей)
- Затем мы переведём набор токенов снова в текст, его лексим, парсим и далее
Маленькое уточнение: `"the cat says 'meow'"` – один большой `doubleQuoteToken`.

После этого список токенов передаётся в парсер, который строит дерево (что-то вроде бамбука в наших ограничениях) в соответствии с правилами, описанными выше.

Теперь обсудим, что делать с построенным деревом. У каждой команды есть `execute(context: IoContext, env: Environment): ExecutionResult`, отвечающая за исполнение команды. Из первого аргумента каждая команда будет знать, откуда получать данные, куда отправлять данные и куда писать при получении ошибок. Второй аргумент хранит всю информацию о переменных, а также текущую директорию (что полезно, например, для PwdCommand). С помощью `PipeCommand` мы объединяем в одну цепочку все написанные команды. Она отвечает за то, чтобы создать фиктивный `OutputStream` для левой команды, потом превратить его в `InputStream` правой команды и т.д.

Также каждая команда хранит специфичную для нее информацию. Например, `EchoCommand` хранит список того, что надо вывести. 

`ExecutionResult` - sealed class, который отвечает за коды возврата и завершение исполнения. В нашем случае у него 2 наследника: `CodeResult` и `ExitResult`
- `CodeResult` возвращается в большинстве случаев и содержит в себе код возврата. На данный момент нет поддержки передачи кода возврата с следующую команду, так как нет команд, использующих это. Но это можно легко поддержать, сохраняя код возврата в environment, или немного изменить `Command.execute`. Сейчас же код возврата используется только в `CommandExecutor`, и может например сохранятся (если вдруг `$?` появится в будущем) или завершать исполнение всей программы с тем же кодом возврата.
- `ExitResult` возвращается в случае команды `exit` и завершает исполнение, если этот `ExecutionResult` был получен в `CommandExecutor` (то есть был последним в цепочке `pipe`-ов), иначе игнорируется

`IOContext` – `data class (== POJO)` с тремя основными потоками: `stdout`, `stdin`, `stderr`

`Environment` – окружение исполнения, который хранит все описанные ранее переменные (в `Map`) и рабочую директорию

`CommandExecutor` – класс, создающийся в `Main`. Обладает единственным методом `execute(command: String): ExecutionResult`, который выполняет команду (лексит, парсит, вызывает `run` у команды).
Поля `CommandExecutor` – лексер и парсер, environment и `iocontext` (смотри выше)

Внешние команды запускаются с помощью `ProcessBuilder`. У созданных `Process` есть `getInputStream`, `getOutputStream`, `getErrorStream`, и полученные потоки используются в `PipeCommand`.


Теперь поговорим об общем потоке исполнения. `Main` создает `CommandExecutor`, отдает ему `input`/`output`/`err` и запускает бесконечный цикл, который делает следующее:
Спрашивает пользователя новую команду
Отправляет ее `CommandExecutor` и получает результат
Если она вернула `ExitResult`, то цикл заканчивается, иначе все сначала
