# Архитектура игры WitcherRogue

## Разработчики

- Лебедев Егор
- Карнаухов Кирилл
- Худяков Юрий
- Сурков Петр

## Общие сведения о системе

### Назначение

WitcherRogue -- игра с тайтловой графикой в жанре Rogue-like.

### Описание

Есть главный герой, которым управляет игрок. Он попадает на уровень, в котором должен убить босса. Сделать это сразу он,
вероятно, не сможет. Сначала придётся убивать мелких мобов и собирать улучшения для героя:
новое оружие, зелья и броню. В игре также есть таймер, засекающий время одной игры.

### Границы системы

- Игра предназначена для одного человека, для игры на одном компьютере
- В игре есть главный герой, которым управляет игрок
- Управление героем осуществляется с помощью клавиатуры, клавиши для управления можно задавать в настройках
- Игра происходит в реальном времени
- Игру нельзя сохранить или загрузить, весь прогресс после смерти героя сбрасывается
- Уровни в игре генерируются автоматически, но можно загрузить готовый уровень из файла
- Игровой мир состоит из тайтлов, в каждом тайтле может находиться лишь одна сущность: герой, моб, стена, улучшение для
  героя
- Герой может перемещаться в 4 стороны (вверх, вниз, влево, вправо)
- В игре есть только ближний бой. Для атаки героя должны находиться на соседних тайтлах. Бой происходит автоматически,
  результат зависит от параметров оружия (у оружия есть вилка в рамках которой наносится урон) и героя.
- Язык английский, но есть возможность добавить перевод на другие языки

### Контекст системы

Игра должна запускаться без необходимости установки сторонних библиотек и на всех основных платформах.

## Architectural drivers

### Технические ограничения

Для выбранного языка должен существовать игровой движок с тайтловой графикой

### Бизнес-ограничения

- Результат через 2 месяца
- Высокая оценка по SD

### Качественные характеристики системы

- Сопровождаемость
- Расширяемость
- Масштабируемость

### Ключевые функциональные требования

- В игре тайтловая графика, вид сверху
- В игре есть герой, способный перемещаться по карте в 4 основных направлениях
- Герой атакует рядом находящихся соперников
- Бой происходит автоматически
- В игре есть враждебные мобы, из убийства которых выпадают предметы
- Зелья могут влиять на характеристики героя и врагов

## Роли и случаи использования

### Роли

- Игрок
- Дизайнер уровней

Случаи использования:
- Игрок хочет сыграть. Игрок должен иметь цель, иначе ему станет скучно, поэтому игра должна быть конечной и в конце иметь босса
- Дизайнер уровней. Хочет создать уровень, и не хочет лезть в код. Значит, нужно, чтобы он менял читаемое представление уровня в файле

### Типичный пользователь

Имя: Тимофей

Возраст: 35 лет

![user](img/user.jpeg)

Пользуется macos, увлекается машинным обучением, весной ездит в "отпуск". В "отпуске" любит отвлечься от работы, играя в
Rogue-like и критикуя студентов за их игры.

## Viewpoint

### Композиция

![Components](img/components.svg)

Слоистая архитектура.

- Input events handler: детектирует нажатие клавиш с клавиатуры
- Fight handler: детектирует нахождение врагов по близости и атакует их
- Items handler: управление предметами внутри игры
- Level model: хранит внутри себя уровень и состояние предметов
- Level generator: создаёт игровой уровень
- Custom levels: загружает кастомные уровни
- Character model: отвечает за положения персонажей (герой или мобы) и их состояния
- GUI inventory view: для отображения инвентаря героя
- GUI level view: отображение уровня
- GUI menu: меню

### Логическая структура

![Classes](img/classes.svg)

- InputHandler: детектирует клавиши и отправляет их в PlayerController. 
- Timer: каждые Х времени (тик) вызывает метод invoke() у тех Action-ов, которые были зарегистрированы в нем.
- Action: событие, которое исполняется каждый тик. Само проверяет, нужно ли ему исполняться в этот тик, и само делает
какие-то обновления с игрой
  - CharacterAction: получает у CharacterController произошедшие события и запускает их все
  - UpdateViewAction: каждый тик заставляет View перерисовать картинку
  - скорее всего, по большей части анонимные классы, создаваемые контроллерами
- LevelGenerator: генерирует новый уровень (новый класс MapState).
  - RandomLevelGenerator - случайный уровень
  - UserLevelGenerator - уровень от пользователя

- State: часть состояния игры, с которым идёт взаимодействие через контроллеры. Пока не продумали, но вполне можно сделать
паттерн компоновщик, который поможет, если заходим сохранять стейт игры 
  - CharacterState: местоположение, контроллер, текущее здоровье, предметы и примененные зелья и броня.
    - Player: информация о игроке
    - Mob: информация о мобе.
        - RegularMob: обычный моб.
            - WitchMob: ведьма.
            - DogMob: сторожевой пес.
            - GuardianMob: сторож.
            - RogueMob: разбойник.
            - BossMob: босс.
  - InventoryState: информация об инвентаре игрока или моба
    - Item.
        - Weapon: определяет диапазон урона и прочность.
            - SwordWeapon: меч.
        - Armor: текущее состояние брони и от чего защищает.
        - Potion: эффект зелья.
  - MapState: информация о всех тайтлах на уровне.
    - CellState: информация о тайтле (содержимое и местоположение).
      - CellContent: что конкретно находится внутри тайтла.
          - CharacterCellContent: герой или моб.
              - PlayerCellContent: герой.
              - MobCellContent: моб.
          - WallCellContent: часть карты, по которой нельзя ходить.
          - SpaceCellContent: часть карты, по которой можно ходить.
  - GlobalState: глобальное состояние игры - прошедшее время, жив ли герой и босс
  - SettingsState: настройки игры


- Controller
  - CharacterController: управление героем или мобом (перемещение, использование предметов, принятие эффекта зелья,
    использование инвентаря). Каждый тик отдаёт список Action-ов, которые успели произойти 
      - PlayerController: управление героем с помощью приходящей ему информации11 от InputHandler. Происходящие события
    запоминаются в виде Action-ов, которые каждый тик отдаются в CharacterAction и запускаются (т.е. события с клавиатуры
    применяются раз в тик)
      - MobController: управление мобом с помощью AI. Возможно, отдельный поток, который генерирует события моба и 
    действует аналогично PlayerController
  - InventoryController: хранит информацию о предметах внутри инвентаря у персонажа, умеет добавлять и удалять предметы.
  - MapController: контроллер для взаимодействия с картой
  - GlobalController: контроллер для взаимодействия с глобальным состоянием
  

- View
  - InterfaceView.
      - ItemView: отображение предмета.
          - WeaponView: отображение оружия.
          - PotionView: отображение зелья.
          - ArmorView: отображение брони.
      - InventoryView: отобразить список предметов в инвентаре.
      - HealthView: отображение здоровья персонажа.
      - TimerView: отображение таймера.
  - LevelView: отображение уровня.
  - CellView: отображение тайтла.
  - MenuView: отображение меню.
  - SettingsView: отображение настроек.

### Взаимодействия

![Sequence](img/seq.svg)

Взаимодействие в игре построено на основе времени и тиков. Есть Timer, в котором разные сущности игры регистрируют события. 
Эти события выполняются раз в тик (например, 1мс). Событие само понимает, когда ему надо что-то делать, а когда нет, 
и если нужно, удаляет себя из событий в Timerе.
Когда игрок нажимает клавишу, это передаётся в PlayerController. PlayerController хранит ещё не обработанные события. 
Каждый тик Timer опрашивает его, какие у него появились события, затем эти события регистрируются и начинают исполняться. 
Одноразовые события делаются по схеме: register - do stuff - forget, но можно и вызывать их на месте.
Аналогично интеллект мобов добавляет события, которые они должны совершить.

Больше подробностей о происходящих в игре событиях:
- Бой: персонаж и моб атакуют друг друга в зависимости от их брони и оружия, уменьшая их здоровье. Бой заканчивается,
  когда кто-то из них умирает. Происходит, когда два враждебных персонажа стоят на соседних клетках.
- Поднятие предмета: когда персонаж подходить к предмету и решает его взять, то предмет переходит в инвентарь.
- Использование зелья: персонаж может применить зелье на себя или другого персонажа, влияя на его характеристики. Могло бы
быть отдельным состоянием (e.g. PoisonedState), но на диаграмме получится в 2 раза больше состояний и это скорее атрибут 
- Использование оружия: если у персонажа есть в инвентаре оружие, он может его взять и использовать в бою.
- Использование брони: если у персонажа есть в инвентаре броня, он может ее надеть на себя.

### Состояния

## Глобальное состояние игрока

![State](img/state.svg)

Глобально есть состояние MenuState - просто сидим в меню, состояние WalkState - просто идём по полю, состояние FightState -
находимся в бою, состояние InventoryState - открыли инвентарь, состояние DeadState - умерли, состояние VictoryState - в бою убили босса

Также отдельно о состояниях различных элементов системы:
- Состояние героя:
    - Ведет бой.
    - Не ведет бой.
    - Открыл инвентарь
    - Умер
    - Победил
- Состояние моба:
    - Ведет бой.
    - Собирается начать бой (идет к нему).
    - Игнорирует героя.
- Состояние игры:
    - В процессе.
    - Победа.
    - Проигрыш.
- Состояние предмета:
    - Лежит на земле.
    - Использовано.
    - Лежит в инвентаре у персонажа.

## Принятые решения

Мы выбрали язык Kotlin, потому что он удобен в использовании, наша команда его хороша знает, а также в нем есть
подходящий игровой движок. Мы не выбрали C#, потому что большая часть команды не имела с ним опыта. Мы не выбрали C++,
потому что на нем намного сложнее реализовывать большие системы, а производительности Kotlin более, чем достаточно.

Для игрового движка мы выбрали [KorGE](https://korge.org/) по следующим причинам:
* В нем есть тайтловая графика
* Это современный игровой движок
* Он мультиплатформенный
* В нем есть примеры реализации Rogue-like игр
